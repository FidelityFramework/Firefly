# Async Implementation: LLVM Coroutines

## Overview

This document explains Fidelity's approach to implementing F# async computation expressions using LLVM coroutine intrinsics rather than the MLIR async dialect.

## The Problem with MLIR Async Dialect

The MLIR async dialect provides operations like `async.execute`, `async.await`, and `async.value`. However, the standard lowering path requires linking against a **runtime library**:

```
async dialect → AsyncToLLVM pass → mlir-async-runtime library
```

The `mlir-async-runtime` library provides:
- `mlirAsyncRuntimeCreateToken()`
- `mlirAsyncRuntimeAwaitToken()`
- `mlirAsyncRuntimeExecute()`
- Thread pool management
- Memory allocation

**This conflicts with Fidelity's goals:**
1. **Freestanding mode**: No runtime dependencies
2. **Minimal deps mode**: Only libc, no extra libraries
3. **Deterministic allocation**: Stack/arena only, no hidden malloc

## The Solution: LLVM Coroutines

LLVM provides coroutine intrinsics that compile to **state machines at compile time**. No runtime library is needed.

### How LLVM Coroutines Work

```llvm
; Coroutine intrinsics
%id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
%size = call i64 @llvm.coro.size.i64()
%mem = call ptr @my_alloc(i64 %size)
%hdl = call ptr @llvm.coro.begin(token %id, ptr %mem)

; Suspension point
%0 = call i8 @llvm.coro.suspend(token none, i1 false)
switch i8 %0, label %suspend [
  i8 0, label %resume
  i8 1, label %cleanup
]
```

The LLVM `CoroSplit` pass transforms this into a state machine struct:

```c
// Generated by LLVM
struct coro_frame {
  int state;        // Current suspension point
  // ... captured variables ...
};

bool coro_resume(struct coro_frame* f) {
  switch (f->state) {
    case 0: goto resume_point_0;
    case 1: goto resume_point_1;
    // ...
  }
}
```

### Benefits

| Aspect | MLIR Async | LLVM Coroutines |
|--------|------------|-----------------|
| Runtime dependency | mlir-async-runtime | None |
| Memory allocation | Hidden malloc | Explicit (stack/arena) |
| Thread management | Runtime thread pool | None (single-threaded or explicit) |
| Freestanding support | No | Yes |
| State machine | Runtime dispatch | Compile-time generated |

## Mapping F# Async to LLVM Coroutines

### F# Async Computation Expression

```fsharp
async {
    let! data = fetchDataAsync()
    let processed = process data
    return processed
}
```

### Desugared Form (FNCS)

```fsharp
Async.Bind(fetchDataAsync(), fun data ->
    let processed = process data
    Async.Return processed)
```

### LLVM Coroutine Representation

```llvm
define ptr @async_body(ptr %async_state) presplitcoroutine {
entry:
  %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
  %hdl = call ptr @llvm.coro.begin(token %id, ptr %async_state)

  ; Call fetchDataAsync and get awaitable
  %awaitable = call ptr @fetchDataAsync()

  ; Suspension point for let!
  %suspend_result = call i8 @llvm.coro.suspend(token none, i1 false)
  switch i8 %suspend_result, label %suspend [
    i8 0, label %resume
    i8 1, label %cleanup
  ]

resume:
  ; Get data from completed awaitable
  %data = call ptr @get_awaitable_result(ptr %awaitable)

  ; Process data
  %processed = call ptr @process(ptr %data)

  ; Return result
  store ptr %processed, ptr %async_state
  br label %cleanup

cleanup:
  %mem = call ptr @llvm.coro.free(token %id, ptr %hdl)
  ; ... cleanup code ...
  call void @llvm.coro.end(ptr %hdl, i1 false, token none)
  ret ptr %hdl

suspend:
  call void @llvm.coro.end(ptr %hdl, i1 true, token none)
  ret ptr %hdl
}
```

## State Machine Struct

The coroutine frame is a struct containing:

```fsharp
type AsyncFrame<'T> = {
    mutable State: int           // Current suspension point (0, 1, 2, ...)
    mutable Result: 'T           // Final result
    mutable Awaiting: Awaitable  // Current thing being awaited
    // ... captured variables from enclosing scope ...
}
```

In MLIR/LLVM:

```mlir
!async_frame = !llvm.struct<(
  i32,                           // state
  !llvm.ptr,                     // result pointer
  !llvm.ptr,                     // awaiting pointer
  // ... captured variables ...
)>
```

## Integration with Fidelity

### FNCS Intrinsics

New intrinsic module `Async` with operations:

| Intrinsic | Type | Purpose |
|-----------|------|---------|
| `Async.Return` | `'T -> Async<'T>` | Wrap value in completed async |
| `Async.Bind` | `Async<'T> -> ('T -> Async<'U>) -> Async<'U>` | Monadic bind |
| `Async.Start` | `Async<unit> -> unit` | Fire-and-forget execution |
| `Async.RunSynchronously` | `Async<'T> -> 'T` | Block until completion |

### Alex Generation

Alex generates LLVM IR with coroutine intrinsics:

1. **Async builder recognition**: Detect `async { }` computation expression
2. **Suspension point insertion**: At each `let!` / `do!` / `return!`
3. **Frame allocation**: Stack or arena based on context
4. **Coroutine metadata**: LLVM attributes for CoroSplit pass

### MLIR Emission

```mlir
// For: async { let! x = fetch(); return x + 1 }

llvm.func @my_async(%state: !llvm.ptr) -> !llvm.ptr attributes {passthrough = ["presplitcoroutine"]} {
  %id = llvm.call @llvm.coro.id(...)
  %hdl = llvm.call @llvm.coro.begin(%id, %state)

  // Call fetch
  %fetch_result = llvm.call @fetch()

  // Suspend
  %susp = llvm.call @llvm.coro.suspend(...)
  llvm.switch %susp : i8, ^suspend [
    0: ^resume,
    1: ^cleanup
  ]

^resume:
  %x = // ... extract result ...
  %result = arith.addi %x, %c1
  llvm.store %result, %state[result_offset]
  llvm.br ^cleanup

^cleanup:
  llvm.call @llvm.coro.end(...)
  llvm.return %hdl

^suspend:
  llvm.call @llvm.coro.end(...)
  llvm.return %hdl
}
```

## Execution Model

### Single-Threaded (Default)

Without explicit threading, async operations run cooperatively:

```fsharp
// Runs on main thread with explicit yield points
let result = Async.RunSynchronously myAsync
```

The coroutine state machine executes synchronously, with suspension points becoming explicit checks for completion.

### Multi-Threaded (Explicit)

Threading is explicit via platform primitives:

```fsharp
// Explicit thread spawn (Fidelity.Platform)
let thread = Thread.spawn (fun () ->
    Async.RunSynchronously backgroundWork
)
Thread.join thread
```

## Comparison with Other Approaches

| Approach | Used By | Runtime | State Machine |
|----------|---------|---------|---------------|
| LLVM Coroutines | Fidelity, Rust, C++20 | None | Compile-time |
| MLIR Async | MLIR projects | mlir-async-runtime | Runtime |
| Task/ValueTask | .NET | CLR + ThreadPool | Runtime |
| Tokio | Rust (alternative) | tokio runtime | Runtime |

## Future: DCont Integration

The current LLVM coroutine approach is an interim solution. The long-term vision is **Delimited Continuations (DCont)**:

- Unified abstraction for async, actors, sequences, computation expressions
- More expressive than state machines
- Better composability

The LLVM coroutine implementation provides a working foundation while DCont is developed.

## Related Documentation

- [WRENStack_Roadmap.md](./WRENStack_Roadmap.md) - Overall architecture
- [FidelityHelloWorld_Progression.md](./FidelityHelloWorld_Progression.md) - Sample progression including async
- [FNCS_Architecture.md](./FNCS_Architecture.md) - Intrinsic definition system
- `~/repos/Firefly/.serena/memories/delimited_continuations_architecture.md` - DCont vision

## References

- [LLVM Coroutines Documentation](https://llvm.org/docs/Coroutines.html)
- [MLIR Async Dialect](https://mlir.llvm.org/docs/Dialects/AsyncDialect/)
- Rust async implementation (uses LLVM coroutines)
- C++20 coroutines specification
